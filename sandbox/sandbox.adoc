== Получение данных

Пользователь получает данные через `GET /data/{id}`



[source, json]
----
{
   "mcv":2,
   "tds":1458965214,
   "ui":{
     "name":"",
     "rev":33
   },
   "data":{
      "title":"Title for entity",
      "body":"Can be long <h2>html</h2> text",
      "photo":{
         "id":4,
         "name":"IMG_20150324_120506.jpg"
      },
      "location":{
         "lon":49.1420645,
         "lat":55.7745272,
         "date":1422336455000
      }
   }
}
----
[cols="1,2", options="header"]
|===
|Field
|Info

|mcv
|link:../versioning/versioning.adoc[о версионировании] +
link:../migration/migration.adoc[о миграции]

|===

Но чтобы отправить свои изменения от делает `POST /changes/{id}`. не `/data/{id}` - этого роута вообще быть не должно и не будет

[source, json]
----
{
  "mcv":2,
  "tds":1458965214,
  "tdc":1456874526,
  "tuc":1456889564,
  "failedUploads":[
    {
      "time":14568745445,
      "cause":"Тут текст или код ошибки надо отправлять. ошибка может быть локальная или от сервера."
    }
  ],
  "changes":{
    "title":[
      {
        "time":1456987562,
        "value":"Первое изменение поля"
      },
      {
        "time":1456987662,
        "value":"Второе изменение поля"
      },
    ]
  }
}
----

Лучше поздно, чем никогда. Обычно при появлении в компании новых сотрудников в этом чате уведомляют о пополнении сообщением. Пусть все же с опозданием...
Приветствуйте, Дмитрий и Марат. Они с нами уже более полугода. Длительная стажировка сейчас закончилась трудоустройством, поэтому теперь они официально с нами.

[cols="1,4"]
|===
|mcv
|Это именно то поле, которое пришло с задачей. Передаем его в неизменном виде. Это нужно для миграции. link:../migration/migration.adoc[о миграции]

| td* и tu*
| Детальное описание предназначения полей начинающихся на td* и tu* тут

|tds
|Это то поле которое мы получаем от сервера, используем его в неизменном виде, просто отсылаем обратно.
В паре с полями описанными ниже все это используется для журналирования и решения некоторых технических проблем +
link:../journaling/problems.adoc[подробнее]

|tdc
|Когда клиент получил данные от сервера он должен был записать сюда свое локальное время.
Просто используем это значение и передаем в неизменном виде.

|tuc
|Это локальное время постановки этого перечня изменений на отправку. Это спорное поле. Тут надо будет подумать как это реализовывать. Пока на это поле стараемся ничего не завязывать. см проблемы дедупликации выше. Тесно связано с failedUploads

|failedUploads
|Опциональное поле. Каждый раз когда пользователь в ручном режиме жмет кнопку отправить изменения на сервер(принудительно синхронизирует) и это не выполняется из-за разного рода ошибок - это время журналируется
|===

[cols="1,2,4"]
|===
|tds
|TIME DOWNLOAD from the SERVER +
(server time)
|Серверное время, когда сформировался ответ клиенту

|tdc
|TIME DOWNLOAD to CLIENT +
(local client time)
|Локальное время девайса, когда ответ был получен от сервера. разница tdc-tds = transfer time + delta (защита от неточного время на клиенте)

|tuc
|TIME UPLOAD from CLIENT +
(local client time)
|Локальное время девайса, когда запланирована отправка изменений на сервер. Сервер потом припишет еще свое время получения изменений от клиента - tus.

|tus
|TIME UPLOAD to SERVER +
(server time)
|_Это поле в JSON'е от клиента серверу не передается!_ оно появится на сервере. Это серверное время, когда сервер получил изменения от клиента.разница tus-tuc = transfer time + delta (защита от неточного время на клиенте)
|failedUploads
|-
|Опциональное поле. Каждый раз когда пользователь в ручном режиме жмет отправить и это проходит не успешно - это журналируется
|===

Изменение в офлайне, это некая сессия. Каждый раз меняя поле, история об этом записывается.
Именно в тот момент, когда поле меняется. Все записывается в историю по этому полю.
время, когда пользователь забрал - является сессией для оффлайна. Используется для показа истории. Все промежуточные значения не используются, для этой сессии берётся последнее. Это на сервере можно резать и выкидывать. А на клиенте это позволит делать undo.
А на сервере позволит отображать изменения отсортированные по дате внесения изменений, и по сессии. Может ещё внести дату когда пользователь отправил данные? По сути это тоже будет sessionID
},{}]

Когда изменения полей загружаются на сервер, каждое изменение сделанное пользователем устанавливается в соответствующую позицию. Получается они могут быть перемешаны с изменениями других пользователей, которые делались в этот же самый момент. Поэтому важным моментом еще является и сам факт загрузки. Поэтому его тоже в истории надо отображать. Изменения полей делались в течении дня. потом вечером пытались отправить. неуспешно. Это тоже можно фиксировать.даже с причиной неуспешной отправки. Это я говорю только про ручной режим. Когда пользователь явно жмет кнопку отправить. Когда в фоне пытается отправиться - не учитывается.  И успешная попытка отправки тоже должна быть зафиксирована в ленте с историей. Прям пункт, что пользователь залил свои изменения на сервер. Это отголоски журналирования.

Надо защищаться от разницы во времени серверное и локальное. Когда пользователь забирает задание время ставить с сервера и сразу писать локальное время.
